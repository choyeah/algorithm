let input = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n");

let [N, K] = input[0].split(" ").map(Number);
let sum = 0; // 각 바구니에 공을 최소한으로 배분했을 때 필요한 총 공의 개수
for (let i = 1; i <= K; i++) {
  sum += i;
}

if (sum > N) {
  console.log(-1);
} else {
  // N개의 전체 공 중에서 sum만큼을 사용하였을때, 남은 공은 어떻게 배분할 것인가?
  // 남은 공이 있다면, 이를 다시 규칙에 맞게 바구니에 배분해야 한다.
  N -= sum; // 이제 N은 남은 공의 개수

  // 남은 공 N을 K개의 바구니에 고르게 나눌 수 있는지 확인하는 조건문입니다.
  // N을 K로 나눈 나머지가 0이면 모든 바구니에 동일한 개수의 공을 추가로 넣을 수 있다는 것입니다.
  if (N % K == 0) {
    /**
     * 가장 큰 개수가 들어가는 바구니와 가장 적은 개수가 들어가는 바구니 사이의 차이가 K−1K−1이 되는 이유
     * 나머지가 0이라는 것은 추가로 나눠주어야 하는 모든 공을 균등하게 바구니에 나눠줄 수 있다는 것을 의미합니다. 즉, 각 바구니에는 동일한 개수의 추가 공이 들어갑니다.
     * 기본적으로 각 바구니에는 1,2,3,...,K와 같이 공이 들어가 있을 것입니다.
     * 여기에 동일한 개수의 공, 예를 들어 x를 추가로 넣으면, 바구니에 들어가는 공은 1+x,2+x,3+x,...,K+x가 됩니다.
     * 이 경우, 가장 많은 공이 들어있는 바구니와 가장 적은 공이 들어있는 바구니의 차이는 (K+x)−(1+x)=K−1(K+x)−(1+x)=K−1가 됩니다.
     */
    console.log(K - 1);
  } else {
    /**
     * 나머지가 0이 아닌 경우, 즉 N mod K ≠ 0일 때, 나머지를 하나의 바구니에 추가로 할당할 수 있습니다. 이렇게 하면 그 바구니에 들어있는 공의 개수가 하나 더 늘어나게 됩니다.
     * 기존에 각 바구니에 1,2,3,...,K 개의 공이 들어가 있었다고 하면, 나머지를 가장 많은 공이 들어있는 K번째 바구니에 추가로 할당하면, 바구니에 들어가는 공의 수는 1,2,3,...,K+1이 됩니다.
     * 이렇게 되면, 가장 많은 공이 들어있는 바구니와 가장 적은 공이 들어있는 바구니의 차이는 (K+1)−1=K(K+1)−1=K가 됩니다.
     * 그러므로 나머지가 0이 아니라면, 결과가 K가 됩니다.
     */
    console.log(K);
  }
}
/**
 * 이 문제의 조건에서는 모든 바구니에 공이 최소한 하나씩은 들어가야 하고,
 * 각 바구니에 들어가는 공의 개수는 모두 달라야 한다는 점을 고려하면, 두 가지 경우밖에 나올 수 없습니다.
 */
